\newpage


\section{Разработка программной системы, реализующей последовательный алгоритм обработки}\label{sec:devprog}
Разработать программу обработки изображений на C++ не простая задача.
Во-первых, необходимо придумать способ загрузки изображения в программу так, чтобы с загруженным изображением было удобно работать.
Во-вторых, программа должна быть модульной и гибкой для последующих доработок и распараллеливания.

Для загрузки и сохранения изображения и использовал \textbf{bitmap}.
Это удобный модуль, хранящий изображение в матрице пикселей в формате \textbf{RGB}.
Так как картинка заведомо чёрно-белая, то все каналы имеют одинаковое значения, поэтому для формирования матрицы используется зелёный канал.

Интересно, что C++ использует файл как единицу трансляции.
Поэтому для достижения модульности совершенно не обязательно создавать классы, структуры или функции лишнего порядка.
Взаимодействие \textbf{.h} и \textbf{.cpp} файлов само по себе может обеспечить достаточный уровень инкапсуляции и необходимую гибкость, как если бы я использовал класс через интерфейс.
Поэтому, дабы не усложнять код лишний раз, используется необычный подход C++ к файлам.

Как я уже сказал, модульность достигается за счет совместного использования \textbf{.h} и \textbf{.cpp} файлов.

\textbf{.h} --- интерфейс функций загрузки картинки, её обработки и сохранения.
Также этот файл содержит размер изображения как константу.

\textbf{.cpp} --- реализация интерфейса.
Этот файл содержит определение всех функций, также он хранит в себе матрицу пикселей и буферную матрицу пикселей, а также дополнительные функции и определения типов, необходимых для внутреннего использования.

\subsection{Тонкости работы функций обработки изображения.}\label{subsec:imageprocessingPickUpOn}
Стоит сказать, что функции обработки изображений используют пару оптимизаций и элементы функционального программирования.

А именно, после обработки основной матрицы с использованием буферной матрицы, данные из буферной матрицы нужно скопировать обратно в основную.
Это копирование реализовано при помощи функции \textbf{memcpy()}, что намного быстрее, чем поэлементное копирование.

Определение, является ли сосед достаточно ярким или достаточно тёмным в функциях увеличения/уменьшения использует функцию как параметр.
Эта функция имеет следующую сигнатуру: \textbf{bool func(u\_char value)}.
